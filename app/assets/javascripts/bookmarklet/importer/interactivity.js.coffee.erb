//= require templates/bookmarklet/importer/iframe_loader

window.ppImporterClasses ?= {}
class window.ppImporterClasses.Interactivity
  
  # Global Class Config
  host                = window.ppBookmarklet.host
  stepOneURL          = host + '<%= Rails.application.routes.url_helpers.pin_import_step_1_path %>'   # Loaded in iframe directly from PP
  stepTwoURL          = host + '<%= Rails.application.routes.url_helpers.pin_import_step_2_path %>'   # Loaded in iframe directly from PP
  loaderImageURL      = host + '<%= asset_path("ui/loader.gif") %>'
  frameWrapperMargin  = 50

  outputDiv           = window.ppBookmarklet.contentBase
  outputDivWrapper    = outputDiv.parents('#ppBookmarkletContentWrapper')
  

  # When viewing an image directly, the browser creates minimal surrounding HTML that doesn't include a HEAD section
  appendTarget      = document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]

  # Share pp info retreived via ajax among any multiple instances (there should only be one, but still)
  ppPins = null
  ppBoards = null
  
  
  
  # ==================================================================
  # = Private functions that don't need access to instance variables =
  # ==================================================================
  
  # Odd timing issue with loading of bookmarklet SCSS, need to repaint window after step1 loaded
  toggleWindowRepaint = () ->
    body = $('body').first()
    curHeight = body.height()
    body.height(curHeight - 1).height(curHeight)

  # =======================================
  # = Methods (public interface of class) =
  # =======================================
  
  setHeader: (msg) ->
    # TODO: grab containing element from parent, pass into children, rather than this search over the whole page
    $('#ppHeaderCenter').html(msg)
  
  start: (data) ->
    @externalPinData = data.pins
    @externalBoardData = data.boards
    if @externalPinData.length == 0
      outputDiv.find('#noPotentialImages').html('No importable pins found.').addClass('red')
    else if window['postMessage']
      @transitionToStepOne()
    else
      outputDiv.find('#noPotentialImages').html('You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/" target="blank">upgrade your browser</a> to enable importing pins.').addClass('red')
      @bookmarkletClosing()
    toggleWindowRepaint()

  bookmarkletClosing: () ->
    $(window).off 'message', @handleAnyPostedMessage
    @iframeWrapper.find('iframe').remove() if @iframeWrapper
    
  
  # Note we define all methods under constructor to keep them private
  constructor: (@parent) ->
    unless window.ppBookmarklet
      alert("Importer must be loaded from the ParentPins bookmarklet!")
      return false

    # Instance variable declarations
    @iframeWrapper = null
    @stepOneFrame = null
    @stepTwoFrame = null
    @externalPinData = []     # Expects an array with an id, board_id, and various pin fields
    @externalBoardData = []   # Expects an array with at least id and name fields

    # Preload loader img
    loader = new Image()
    loader.src = loaderImageURL

    $(window).on 'message', (evt) =>
      # Only process this message if it was meant for the current instance (e.g. if bookmarklet opened multiple times)
      # TODO: Why aren't we properly removing ourselves / our listeners on bookmarklet close? (This works, but hackish)
      if this == window.ppImporter?.Interactivity
        @handleAnyPostedMessage(evt)
      
    
    # =================================
    # = Implementation helper methods =
    # =================================
    @pinsForBoard = (board_id) ->
      returning = []
      for pin in @externalPinData
        if pin.board_id == board_id then returning.push(pin)
      return returning
    
    @paramsForStepOne = () ->
      boards = {}
      for board in @externalBoardData
        boards[board.id] = {name: board.name, pins: @pinsForBoard(board.id)}

      return $.param({import: {boards: boards}})
    
    @paramsForStepTwo = (dataString) ->
      # Helper to get full data from pin ID
      dataForPinID = (pid) =>
        for pin in @externalPinData
          return pin if pin.id == pid
        null

      # Get full data for all pins to import
      pinsByBoard = {}
      for dataPair in dataString.split(':')
        [boardID, pinID] = dataPair.split('.')
        if pinData = dataForPinID(pinID)
          pinsByBoard[boardID] ?= {pins: []}
          pinsByBoard[boardID].pins.push pinData

      return $.param({from: 'importer', import: {boards: pinsByBoard}})
    
    @ensureFrameWrapper = () ->
      @iframeWrapper ||= $('<div id="ppParentPinsImporterWrapper"></div>').appendTo( outputDiv )  

    @handleAnyPostedMessage = (event) ->
      if event.originalEvent.origin.replace(/^https?:/, '') != host
        console.log('Ignoring message from mismatchted source: ' + event.originalEvent.origin)
      else
        @handlePostedMessage(event.originalEvent)

    @handlePostedMessage = (event) ->
      [step, command, extra...] = event.data.split(':')
      extra = extra.join(':')
      if step == 'step1'
        switch command
          when 'loaded' then @handleFrameOneLoaded()
          when 'next' then @transitionToStepTwo(extra)
          when 'setHeight' then @stepOneFrame?.height( extra )
      else if step == 'step2'
        switch command
          when 'setHeight' then @stepTwoFrame?.height( extra )
          when 'previous'
            @stepTwoFrame.hide()
            @stepOneFrame.show()
            toggleWindowRepaint()
          when 'done' then null # We could hide the iframe, if we wanted...
          when 'imported'
            if @stepOneFrame && @stepOneFrame[0]
              step1 = @parent.getIframeWindow(@stepOneFrame[0])
              step1.postMessage "imported:#{extra}", '*'
              toggleWindowRepaint()


    # =================================================================
    # = Step One - choose pins to import and assign to desired boards =
    # =================================================================

    @transitionToStepOne = () ->
      @ensureFrameWrapper()
      @stepTwoFrame?.hide()
      hideInitially = !@stepOneFrame?.length
      @stepOneFrame ?= $('<iframe class="ppParentPinsImporter stepOne">').appendTo( @iframeWrapper )
      @stepOneFrame.height( outputDivWrapper.height() - frameWrapperMargin )
      if hideInitially then @stepOneFrame.hide() else @stepOneFrame.show()

      doc = @stepOneFrame.contents()[0]
      if doc
        doc.open()
        doc.write( JST['templates/bookmarklet/importer/iframe_loader']({host: host, data_string: @paramsForStepOne(), url: stepOneURL}) )
        toggleWindowRepaint()
      else
        alert("Unable to access document for @stepOneFrame - maybe cross domain security issue?")


    @handleFrameOneLoaded = () ->
      progressDiv = outputDiv.find('#noPotentialImages')
      if progressDiv.is(':visible')
        progressDiv.addClass('no-auto-updates').text("Import Complete!")
        setTimeout (=> 
          progressDiv.slideUp()
          @stepOneFrame.fadeIn()
        ), 700

    # ==============================================================================
    # = Step 2 - set the extra required info for each pin, then actually save them =
    # ==============================================================================

    @transitionToStepTwo = (dataString) ->
      # Now display the Step 2 iframe
      @ensureFrameWrapper()
      @stepOneFrame?.hide()
      @stepTwoFrame.remove() if @stepTwoFrame
  
      @stepTwoFrame = $('<iframe class="ppParentPinsImporter stepTwo" name="ppParentPinsImporterStep2Frame">').appendTo( @iframeWrapper )
      @stepTwoFrame.height( outputDivWrapper.height() - frameWrapperMargin ).show()

      # Note: loading the data as a param string inside a form so we can send a POST request (no URL length limit), but not via ajax (had authentication issues)
      @stepTwoFrame.contents()[0].write( JST['templates/bookmarklet/importer/iframe_loader']({host: host, data_string: @paramsForStepTwo(dataString), url: stepTwoURL}) )
      toggleWindowRepaint()
